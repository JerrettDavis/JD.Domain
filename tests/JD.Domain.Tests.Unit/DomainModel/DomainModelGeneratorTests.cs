using JD.Domain.Abstractions;
using JD.Domain.DomainModel.Generator;
using JD.Domain.Generators.Core;
using JD.Domain.Rules;
using static JD.Domain.Modeling.Domain;

namespace JD.Domain.Tests.Unit.DomainModel;

public class DomainModelGeneratorTests
{
    private class Blog
    {
        public Guid Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public string? Description { get; set; }
        public DateTimeOffset CreatedAt { get; set; }
    }

    private class Post
    {
        public int Id { get; set; }
        public string Title { get; set; } = string.Empty;
        public string Content { get; set; } = string.Empty;
        public Guid BlogId { get; set; }
    }

    private static GeneratorContext CreateContext(DomainManifest manifest, Dictionary<string, string>? properties = null)
    {
        var compilation = Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Create("Test");
        return new GeneratorContext
        {
            Manifest = manifest,
            Compilation = compilation,
            CancellationToken = CancellationToken.None,
            Properties = properties ?? new Dictionary<string, string>()
        };
    }

    [Fact]
    public void Generator_HasCorrectName()
    {
        var generator = new DomainModelGenerator();
        Assert.Equal("DomainModelGenerator", generator.Name);
    }

    [Fact]
    public void CanGenerate_ReturnsFalse_WhenNoEntities()
    {
        var manifest = Create("Test")
            .Version(1, 0, 0)
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();

        Assert.False(generator.CanGenerate(context));
    }

    [Fact]
    public void CanGenerate_ReturnsTrue_WhenEntitiesExist()
    {
        var manifest = Create("Test")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();

        Assert.True(generator.CanGenerate(context));
    }

    [Fact]
    public void Generate_CreatesDomainProxyFile()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        Assert.Single(files);
        var file = files[0];
        Assert.Equal("DomainBlog.g.cs", file.FileName);
        Assert.NotEmpty(file.Content);
    }

    [Fact]
    public void Generate_IncludesAutoGeneratedHeader()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("// <auto-generated>", content);
        Assert.Contains("DomainModelGenerator", content);
    }

    [Fact]
    public void Generate_IncludesRequiredUsings()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("using System;", content);
        Assert.Contains("using JD.Domain.Abstractions;", content);
    }

    [Fact]
    public void Generate_CreatesSealedPartialClass()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("public sealed partial class DomainBlog", content);
    }

    [Fact]
    public void Generate_IncludesPrivateEntityField()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("private readonly Blog _entity;", content);
        Assert.Contains("private readonly IDomainEngine? _engine;", content);
    }

    [Fact]
    public void Generate_IncludesPrivateConstructor()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("private DomainBlog(Blog entity", content);
    }

    [Fact]
    public void Generate_IncludesEntityProperty()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("public Blog Entity => _entity;", content);
    }

    [Fact]
    public void Generate_IncludesImplicitConversion()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("public static implicit operator Blog(DomainBlog domain)", content);
    }

    [Fact]
    public void Generate_IncludesCreateMethod()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("public static Result<DomainBlog> Create(", content);
    }

    [Fact]
    public void Generate_IncludesFromEntityMethod()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("public static DomainBlog FromEntity(Blog entity", content);
    }

    [Fact]
    public void Generate_IncludesWithMethods()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e =>
            {
                e.Key(x => x.Id);
                e.Property(x => x.Name);
            })
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("public Result<DomainBlog> WithName(", content);        
    }

    [Fact]
    public void Generate_WithMethods_OmitDomainContextWhenDisabled()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e =>
            {
                e.Key(x => x.Id);
                e.Property(x => x.Name);
            })
            .BuildManifest();

        var properties = new Dictionary<string, string>
        {
            ["IncludeDomainContext"] = "false"
        };
        var context = CreateContext(manifest, properties);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("public Result<DomainBlog> WithName(string name)", content);
        Assert.DoesNotContain("WithName(string name, DomainContext? context = null)", content);
    }

    [Fact]
    public void Generate_IncludesValidateMethod()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("public RuleEvaluationResult Validate(string? ruleSet = null)", content);
    }

    [Fact]
    public void Generate_IncludesPartialClassStub()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        // Should have partial class for extensions
        Assert.Contains("// Add custom methods here", content);
    }

    [Fact]
    public void Generate_KeyPropertyIsReadOnly()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        // Key property should use expression body (read-only)
        Assert.Contains("public Guid Id => _entity.Id;", content);
    }

    [Fact]
    public void Generate_CreatesMultipleFilesForMultipleEntities()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .Entity<Post>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        Assert.Equal(2, files.Count);
        Assert.Contains(files, f => f.FileName == "DomainBlog.g.cs");
        Assert.Contains(files, f => f.FileName == "DomainPost.g.cs");
    }

    [Fact]
    public void Generate_UsesCustomNamespaceWhenProvided()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var properties = new Dictionary<string, string> { { "Namespace", "MyApp.Domain" } };
        var context = CreateContext(manifest, properties);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("namespace MyApp.Domain", content);
    }

    [Fact]
    public void Generate_UsesEntityNamespaceWhenAvailable()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        // Entity has namespace from test assembly, so uses that + ".Domain"
        Assert.Contains("namespace JD.Domain.Tests.Unit.DomainModel.Domain", content);
    }

    [Fact]
    public void Generate_UsesManifestNameWhenEntityHasNoNamespace()
    {
        // Create a manifest without entity namespace to test fallback
        var manifest = new DomainManifest
        {
            Name = "TestDomain",
            Version = new Version(1, 0, 0),
            Entities = new[]
            {
                new EntityManifest
                {
                    Name = "TestEntity",
                    TypeName = "TestEntity",
                    Namespace = null, // No namespace
                    Properties = new[]
                    {
                        new PropertyManifest { Name = "Id", TypeName = "System.Guid" }
                    },
                    KeyProperties = new[] { "Id" }
                }
            }
        };

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("namespace TestDomain.Domain", content);
    }

    [Fact]
    public void Generate_IncludesDomainContextParameter()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("DomainContext? context = null", content);
    }

    [Fact]
    public void Generate_DoesNotTreatNonPropertyRuleExpressionsAsPropertyRules()
    {
        var manifest = new DomainManifest
        {
            Name = "TestDomain",
            Version = new Version(1, 0, 0),
            Entities =
            [
                new EntityManifest
                {
                    Name = "Widget",
                    TypeName = "MyApp.Widget",
                    Namespace = "MyApp",
                    Properties =
                    [
                        new PropertyManifest { Name = "Id", TypeName = "System.Guid", IsRequired = true },
                        new PropertyManifest { Name = "Name", TypeName = "System.String", IsRequired = true }
                    ],
                    KeyProperties = ["Id"]
                }
            ],
            RuleSets =
            [
                new RuleSetManifest
                {
                    Name = "Default",
                    TargetType = "Widget",
                    Rules =
                    [
                        new RuleManifest
                        {
                            Id = "RuleWithoutProperty",
                            Category = "Invariant",
                            TargetType = "Widget",
                            Expression = "x != null"
                        }
                    ]
                }
            ]
        };

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var content = generator.Generate(context).Single().Content;

        Assert.DoesNotContain("ValidateProperty(nameof(Name)", content);
        Assert.Contains("set => _entity.Name = value;", content);
    }

    [Fact]
    public void Generate_PropertiesWithRulesHaveValidation()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e =>
            {
                e.Key(x => x.Id);
                e.Property(x => x.Name);
            })
            .Rules<Blog>(r => r
                .Invariant("NameRequired", x => !string.IsNullOrWhiteSpace(x.Name)))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        // Property setter should have validation
        Assert.Contains("ValidateProperty(nameof(Name), value)", content);
    }

    [Fact]
    public void Generate_CreateMethodIncludesAllParameters()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e =>
            {
                e.Key(x => x.Id);
                e.Property(x => x.Name);
                e.Property(x => x.Description);
            })
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("Guid id,", content);
        Assert.Contains("string name,", content);
    }

    [Fact]
    public void Generate_CustomDomainPrefixIsRespected()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var properties = new Dictionary<string, string> { { "DomainTypePrefix", "Rich" } };
        var context = CreateContext(manifest, properties);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        Assert.Single(files);
        Assert.Equal("RichBlog.g.cs", files[0].FileName);
        Assert.Contains("public sealed partial class RichBlog", files[0].Content);
    }

    [Fact]
    public void Generate_FormatsMappedTypeNames()
    {
        var manifest = new DomainManifest
        {
            Name = "TestDomain",
            Version = new Version(1, 0, 0),
            Entities =
            [
                new EntityManifest
                {
                    Name = "Widget",
                    TypeName = "MyApp.Widget",
                    Namespace = "MyApp",
                    Properties =
                    [
                        new PropertyManifest { Name = "Id", TypeName = "System.Guid", IsRequired = true },
                        new PropertyManifest { Name = "LongValue", TypeName = "System.Int64", IsRequired = true },
                        new PropertyManifest { Name = "BoolValue", TypeName = "System.Boolean", IsRequired = true },
                        new PropertyManifest { Name = "DecimalValue", TypeName = "System.Decimal", IsRequired = true },
                        new PropertyManifest { Name = "DoubleValue", TypeName = "System.Double", IsRequired = true },
                        new PropertyManifest { Name = "FloatValue", TypeName = "System.Single", IsRequired = true },
                        new PropertyManifest { Name = "DateValue", TypeName = "System.DateTime", IsRequired = true },
                        new PropertyManifest { Name = "OffsetValue", TypeName = "System.DateTimeOffset", IsRequired = true },
                        new PropertyManifest { Name = "ByteValue", TypeName = "System.Byte", IsRequired = true },
                        new PropertyManifest { Name = "ShortValue", TypeName = "System.Int16", IsRequired = true },
                        new PropertyManifest { Name = "IntValue", TypeName = "System.Int32", IsRequired = false },
                        new PropertyManifest { Name = "Name", TypeName = "System.String", IsRequired = false },
                        new PropertyManifest { Name = "Owner", TypeName = "MyApp.Owner", IsRequired = false }
                    ],
                    KeyProperties = ["Id"]
                }
            ]
        };

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var content = generator.Generate(context).Single().Content;

        Assert.Contains("public Guid Id => _entity.Id;", content);
        Assert.Contains("public long LongValue", content);
        Assert.Contains("public bool BoolValue", content);
        Assert.Contains("public decimal DecimalValue", content);
        Assert.Contains("public double DoubleValue", content);
        Assert.Contains("public float FloatValue", content);
        Assert.Contains("public DateTime DateValue", content);
        Assert.Contains("public DateTimeOffset OffsetValue", content);
        Assert.Contains("public byte ByteValue", content);
        Assert.Contains("public short ShortValue", content);
        Assert.Contains("public int IntValue", content);
        Assert.Contains("public string Name", content);
        Assert.Contains("public Owner? Owner", content);
    }

    private sealed class Owner
    {
    }

    [Fact]
    public void Generate_RespectsOptions_DisablesOptionalFeatures()
    {
        var manifest = new DomainManifest
        {
            Name = "TestDomain",
            Version = new Version(1, 0, 0),
            Entities =
            [
                new EntityManifest
                {
                    Name = "Widget",
                    TypeName = "MyApp.Widget",
                    Namespace = "MyApp",
                    Properties =
                    [
                        new PropertyManifest { Name = "Id", TypeName = "System.Guid", IsRequired = true },
                        new PropertyManifest { Name = "Name", TypeName = "System.String", IsRequired = false },
                        new PropertyManifest { Name = "Owner", TypeName = "MyApp.Owner", IsRequired = false },
                        new PropertyManifest { Name = "Computed", TypeName = "System.Int32", IsComputed = true },
                        new PropertyManifest { Name = string.Empty, TypeName = "System.String", IsRequired = false }
                    ],
                    KeyProperties = ["Id"]
                }
            ],
            RuleSets =
            [
                new RuleSetManifest
                {
                    Name = "Default",
                    TargetType = "Widget",
                    Rules =
                    [
                        new RuleManifest
                        {
                            Id = "NameRequired",
                            Category = "Invariant",
                            TargetType = "Widget",
                            Expression = "x.Name.Length > 0"
                        },
                        new RuleManifest
                        {
                            Id = "OtherRule",
                            Category = "Invariant",
                            TargetType = "Widget",
                            Expression = null
                        }
                    ]
                }
            ]
        };

        var properties = new Dictionary<string, string>
        {
            ["GenerateWithMethods"] = "false",
            ["GeneratePartialClasses"] = "false",
            ["GenerateImplicitConversion"] = "false",
            ["IncludeDomainContext"] = "false",
            ["PropertyValidationMode"] = "OnDemand",
            ["CreateRuleSet"] = "CreateRules",
            ["DefaultRuleSet"] = "DefaultRules"
        };
        var context = CreateContext(manifest, properties);
        var generator = new DomainModelGenerator();
        var content = generator.Generate(context).Single().Content;

        Assert.DoesNotContain("WithName", content);
        Assert.DoesNotContain("implicit operator", content);
        Assert.DoesNotContain("// Add custom methods here", content);
        Assert.DoesNotContain("DomainContext? context", content);
        Assert.DoesNotContain("_context", content);
        Assert.DoesNotContain("ValidateProperty(nameof(Name)", content);
        Assert.Contains("string name = default", content);
        Assert.Contains("Owner? owner = default", content);
        Assert.Contains("CreateRules", content);
        Assert.Contains("public int Computed => _entity.Computed;", content);
    }

    [Fact]
    public void Generate_MatchesNestedTypesAndAddsValidation()
    {
        var manifest = new DomainManifest
        {
            Name = "TestDomain",
            Version = new Version(1, 0, 0),
            Entities =
            [
                new EntityManifest
                {
                    Name = "Inner",
                    TypeName = "MyApp.Outer+Inner",
                    Namespace = "MyApp",
                    Properties =
                    [
                        new PropertyManifest { Name = "Id", TypeName = "System.Guid", IsRequired = true },
                        new PropertyManifest { Name = "Name", TypeName = "System.String", IsRequired = true }
                    ],
                    KeyProperties = ["Id"]
                }
            ],
            RuleSets =
            [
                new RuleSetManifest
                {
                    Name = "Default",
                    TargetType = "Inner",
                    Rules =
                    [
                        new RuleManifest
                        {
                            Id = "NameRequired",
                            Category = "Invariant",
                            TargetType = "Inner",
                            Expression = "x.Name.Length > 0"
                        }
                    ]
                }
            ]
        };

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var content = generator.Generate(context).Single().Content;

        Assert.Contains("ValidateProperty(nameof(Name)", content);
        Assert.Contains("namespace MyApp.Domain", content);
    }
}
