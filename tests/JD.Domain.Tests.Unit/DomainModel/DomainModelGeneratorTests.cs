using JD.Domain.Abstractions;
using JD.Domain.DomainModel.Generator;
using JD.Domain.Generators.Core;
using JD.Domain.Rules;
using static JD.Domain.Modeling.Domain;

namespace JD.Domain.Tests.Unit.DomainModel;

public class DomainModelGeneratorTests
{
    private class Blog
    {
        public Guid Id { get; set; }
        public string Name { get; set; } = string.Empty;
        public string? Description { get; set; }
        public DateTimeOffset CreatedAt { get; set; }
    }

    private class Post
    {
        public int Id { get; set; }
        public string Title { get; set; } = string.Empty;
        public string Content { get; set; } = string.Empty;
        public Guid BlogId { get; set; }
    }

    private static GeneratorContext CreateContext(DomainManifest manifest, Dictionary<string, string>? properties = null)
    {
        var compilation = Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Create("Test");
        return new GeneratorContext
        {
            Manifest = manifest,
            Compilation = compilation,
            CancellationToken = CancellationToken.None,
            Properties = properties ?? new Dictionary<string, string>()
        };
    }

    [Fact]
    public void Generator_HasCorrectName()
    {
        var generator = new DomainModelGenerator();
        Assert.Equal("DomainModelGenerator", generator.Name);
    }

    [Fact]
    public void CanGenerate_ReturnsFalse_WhenNoEntities()
    {
        var manifest = Create("Test")
            .Version(1, 0, 0)
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();

        Assert.False(generator.CanGenerate(context));
    }

    [Fact]
    public void CanGenerate_ReturnsTrue_WhenEntitiesExist()
    {
        var manifest = Create("Test")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();

        Assert.True(generator.CanGenerate(context));
    }

    [Fact]
    public void Generate_CreatesDomainProxyFile()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        Assert.Single(files);
        var file = files[0];
        Assert.Equal("DomainBlog.g.cs", file.FileName);
        Assert.NotEmpty(file.Content);
    }

    [Fact]
    public void Generate_IncludesAutoGeneratedHeader()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("// <auto-generated>", content);
        Assert.Contains("DomainModelGenerator", content);
    }

    [Fact]
    public void Generate_IncludesRequiredUsings()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("using System;", content);
        Assert.Contains("using JD.Domain.Abstractions;", content);
    }

    [Fact]
    public void Generate_CreatesSealedPartialClass()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("public sealed partial class DomainBlog", content);
    }

    [Fact]
    public void Generate_IncludesPrivateEntityField()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("private readonly Blog _entity;", content);
        Assert.Contains("private readonly IDomainEngine? _engine;", content);
    }

    [Fact]
    public void Generate_IncludesPrivateConstructor()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("private DomainBlog(Blog entity", content);
    }

    [Fact]
    public void Generate_IncludesEntityProperty()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("public Blog Entity => _entity;", content);
    }

    [Fact]
    public void Generate_IncludesImplicitConversion()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("public static implicit operator Blog(DomainBlog domain)", content);
    }

    [Fact]
    public void Generate_IncludesCreateMethod()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("public static Result<DomainBlog> Create(", content);
    }

    [Fact]
    public void Generate_IncludesFromEntityMethod()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("public static DomainBlog FromEntity(Blog entity", content);
    }

    [Fact]
    public void Generate_IncludesWithMethods()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e =>
            {
                e.Key(x => x.Id);
                e.Property(x => x.Name);
            })
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("public Result<DomainBlog> WithName(", content);
    }

    [Fact]
    public void Generate_IncludesValidateMethod()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("public RuleEvaluationResult Validate(string? ruleSet = null)", content);
    }

    [Fact]
    public void Generate_IncludesPartialClassStub()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        // Should have partial class for extensions
        Assert.Contains("// Add custom methods here", content);
    }

    [Fact]
    public void Generate_KeyPropertyIsReadOnly()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        // Key property should use expression body (read-only)
        Assert.Contains("public Guid Id => _entity.Id;", content);
    }

    [Fact]
    public void Generate_CreatesMultipleFilesForMultipleEntities()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .Entity<Post>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        Assert.Equal(2, files.Count);
        Assert.Contains(files, f => f.FileName == "DomainBlog.g.cs");
        Assert.Contains(files, f => f.FileName == "DomainPost.g.cs");
    }

    [Fact]
    public void Generate_UsesCustomNamespaceWhenProvided()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var properties = new Dictionary<string, string> { { "Namespace", "MyApp.Domain" } };
        var context = CreateContext(manifest, properties);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("namespace MyApp.Domain", content);
    }

    [Fact]
    public void Generate_UsesEntityNamespaceWhenAvailable()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        // Entity has namespace from test assembly, so uses that + ".Domain"
        Assert.Contains("namespace JD.Domain.Tests.Unit.DomainModel.Domain", content);
    }

    [Fact]
    public void Generate_UsesManifestNameWhenEntityHasNoNamespace()
    {
        // Create a manifest without entity namespace to test fallback
        var manifest = new DomainManifest
        {
            Name = "TestDomain",
            Version = new Version(1, 0, 0),
            Entities = new[]
            {
                new EntityManifest
                {
                    Name = "TestEntity",
                    TypeName = "TestEntity",
                    Namespace = null, // No namespace
                    Properties = new[]
                    {
                        new PropertyManifest { Name = "Id", TypeName = "System.Guid" }
                    },
                    KeyProperties = new[] { "Id" }
                }
            }
        };

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("namespace TestDomain.Domain", content);
    }

    [Fact]
    public void Generate_IncludesDomainContextParameter()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("DomainContext? context = null", content);
    }

    [Fact]
    public void Generate_PropertiesWithRulesHaveValidation()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e =>
            {
                e.Key(x => x.Id);
                e.Property(x => x.Name);
            })
            .Rules<Blog>(r => r
                .Invariant("NameRequired", x => !string.IsNullOrWhiteSpace(x.Name)))
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        // Property setter should have validation
        Assert.Contains("ValidateProperty(nameof(Name), value)", content);
    }

    [Fact]
    public void Generate_CreateMethodIncludesAllParameters()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e =>
            {
                e.Key(x => x.Id);
                e.Property(x => x.Name);
                e.Property(x => x.Description);
            })
            .BuildManifest();

        var context = CreateContext(manifest);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        var content = files[0].Content;
        Assert.Contains("Guid id,", content);
        Assert.Contains("string name,", content);
    }

    [Fact]
    public void Generate_CustomDomainPrefixIsRespected()
    {
        var manifest = Create("TestDomain")
            .Version(1, 0, 0)
            .Entity<Blog>(e => e.Key(x => x.Id))
            .BuildManifest();

        var properties = new Dictionary<string, string> { { "DomainTypePrefix", "Rich" } };
        var context = CreateContext(manifest, properties);
        var generator = new DomainModelGenerator();
        var files = generator.Generate(context).ToList();

        Assert.Single(files);
        Assert.Equal("RichBlog.g.cs", files[0].FileName);
        Assert.Contains("public sealed partial class RichBlog", files[0].Content);
    }
}
