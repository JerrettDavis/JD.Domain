using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using JD.Domain.Abstractions;
using JD.Domain.Generators.Core;

namespace JD.Domain.FluentValidation.Generator;

/// <summary>
/// Generates FluentValidation AbstractValidator classes from JD rule sets.
/// </summary>
public sealed class FluentValidationGenerator : BaseCodeGenerator
{
    /// <inheritdoc/>
    public override string Name => "FluentValidationGenerator";

    /// <inheritdoc/>
    public override bool CanGenerate(GeneratorContext context)
    {
        return context.Manifest.RuleSets.Count > 0;
    }

    /// <inheritdoc/>
    public override IEnumerable<GeneratedFile> Generate(GeneratorContext context, CancellationToken cancellationToken = default)
    {
        // Group rule sets by target type
        var groupedByType = context.Manifest.RuleSets
            .GroupBy(rs => rs.TargetType)
            .ToList();

        foreach (var group in groupedByType)
        {
            cancellationToken.ThrowIfCancellationRequested();

            var targetType = group.Key;
            var ruleSets = group.ToList();

            // Extract just the class name without namespace for file naming
            var className = targetType.Contains('.') ? targetType.Substring(targetType.LastIndexOf('.') + 1) : targetType;

            // Generate a validator for each rule set
            foreach (var ruleSet in ruleSets)
            {
                var code = GenerateValidator(context, targetType, ruleSet);
                var fileName = GeneratorUtilities.GenerateFileName($"{className}{ruleSet.Name}Validator", "");
                yield return CreateGeneratedFile(fileName, code);
            }
        }
    }

    private string GenerateValidator(GeneratorContext context, string targetType, RuleSetManifest ruleSet)
    {
        var builder = CreateCodeBuilder(context.Manifest.Version.ToString());
        
        // Extract just the class name without namespace
        var className = targetType.Contains('.') ? targetType.Substring(targetType.LastIndexOf('.') + 1) : targetType;
        var validatorName = $"{className}{ruleSet.Name}Validator";

        builder.AutoGeneratedHeader(Name, context.Manifest.Version.ToString())
            .Usings(
                "System",
                "FluentValidation",
                "JD.Domain.Abstractions")
            .AppendLine();

        // Determine namespace from context or use default
        var namespaceValue = GetNamespace(context, className);
        builder.BeginNamespace(namespaceValue);

        // Generate class documentation
        builder.AppendLine("/// <summary>")
            .AppendLine($"/// FluentValidation validator for {className} using the '{ruleSet.Name}' rule set.")
            .AppendLine("/// </summary>");

        builder.BeginClass(validatorName, "public", "sealed", $"AbstractValidator<{className}>");

        // Generate constructor
        builder.AppendLine($"public {validatorName}()")
            .AppendLine("{");
        builder.Indent();

        // Generate rules
        foreach (var rule in ruleSet.Rules)
        {
            GenerateRule(builder, rule, className);
        }

        // Handle includes
        if (ruleSet.Includes.Count > 0)
        {
            builder.AppendLine()
                .AppendLine($"// Includes: {string.Join(", ", ruleSet.Includes)}");
        }

        builder.Unindent();
        builder.AppendLine("}");

        builder.EndClass();
        builder.EndNamespace();

        return builder.ToString();
    }

    private void GenerateRule(CodeBuilder builder, RuleManifest rule, string targetType)
    {
        // Map rule to FluentValidation syntax
        var propertyName = ExtractPropertyName(rule);

        if (string.IsNullOrEmpty(propertyName))
        {
            // Complex rule that can't be easily mapped - add as comment
            builder.AppendLine($"// Rule '{rule.Id}': {rule.Message ?? "No message"}");
            return;
        }

        // Build the rule
        var ruleBuilder = $"RuleFor(x => x.{propertyName})";

        // Add validation based on rule category and metadata
        var validations = new List<string>();

        if (rule.Category == "Invariant" || rule.Category == "Validator")
        {
            // Try to map common patterns
            if (rule.Expression != null)
            {
                if (rule.Expression.Contains("!string.IsNullOrWhiteSpace") || 
                    rule.Expression.Contains("!string.IsNullOrEmpty"))
                {
                    validations.Add("NotEmpty()");
                }
                else if (rule.Expression.Contains(".Length <="))
                {
                    var maxLength = ExtractNumber(rule.Expression);
                    if (maxLength > 0)
                    {
                        validations.Add($"MaximumLength({maxLength})");
                    }
                }
                else if (rule.Expression.Contains(" >= 0"))
                {
                    validations.Add("GreaterThanOrEqualTo(0)");
                }
                else
                {
                    // Generic must condition - use Must with lambda
                    validations.Add($"Must(x => /* {rule.Expression} */ true)");
                }
            }
            else
            {
                // No expression available, use Must placeholder
                validations.Add($"Must(x => /* {rule.Id} */ true)");
            }
        }

        // Add message if provided
        if (!string.IsNullOrEmpty(rule.Message))
        {
            var escapedMessage = GeneratorUtilities.EscapeStringLiteral(rule.Message);
            validations.Add($"WithMessage(\"{escapedMessage}\")");
        }

        // Add severity mapping
        validations.Add($"WithSeverity(Severity.{MapSeverity(rule.Severity)})");

        // Build the complete rule statement
        builder.AppendLine($"{ruleBuilder}");
        builder.Indent();
        foreach (var validation in validations)
        {
            builder.AppendLine($".{validation}");
        }
        builder.Unindent();
        builder.AppendLine(";")
            .AppendLine();
    }

    private string ExtractPropertyName(RuleManifest rule)
    {
        // Try to extract property name from expression
        if (string.IsNullOrEmpty(rule.Expression))
        {
            return string.Empty;
        }

        // Look for patterns like "x.PropertyName" or "b.PropertyName"
        var parts = rule.Expression.Split(new[] { '.', ' ', '(', ')' }, StringSplitOptions.RemoveEmptyEntries);
        if (parts.Length >= 2)
        {
            // Usually the second part after the parameter is the property name
            for (int i = 0; i < parts.Length - 1; i++)
            {
                if (parts[i].Length == 1 && char.IsLower(parts[i][0]))
                {
                    return parts[i + 1];
                }
            }
        }

        return string.Empty;
    }

    private int ExtractNumber(string expression)
    {
        var parts = expression.Split(new[] { ' ', '=', '<', '>' }, StringSplitOptions.RemoveEmptyEntries);
        foreach (var part in parts)
        {
            if (int.TryParse(part, out var number))
            {
                return number;
            }
        }
        return 0;
    }

    private string MapSeverity(RuleSeverity severity)
    {
        return severity switch
        {
            RuleSeverity.Info => "Info",
            RuleSeverity.Warning => "Warning",
            RuleSeverity.Error => "Error",
            RuleSeverity.Critical => "Error", // FluentValidation doesn't have Critical, map to Error
            _ => "Error"
        };
    }

    private string GetNamespace(GeneratorContext context, string targetType)
    {
        // Try to get namespace from context properties
        if (context.Properties.TryGetValue("Namespace", out var namespaceStr))
        {
            return $"{namespaceStr}.Validators";
        }

        // Default namespace
        return $"{context.Manifest.Name}.Validators";
    }
}
