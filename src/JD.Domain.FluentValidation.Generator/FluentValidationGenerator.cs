using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using JD.Domain.Abstractions;
using JD.Domain.Generators.Core;

namespace JD.Domain.FluentValidation.Generator;

/// <summary>
/// Generates FluentValidation AbstractValidator classes from JD rule sets.
/// </summary>
public sealed class FluentValidationGenerator : BaseCodeGenerator
{
    /// <inheritdoc/>
    public override string Name => "FluentValidationGenerator";

    /// <inheritdoc/>
    public override bool CanGenerate(GeneratorContext context)
    {
        return context.Manifest.RuleSets.Count > 0;
    }

    /// <inheritdoc/>
    public override IEnumerable<GeneratedFile> Generate(GeneratorContext context, CancellationToken cancellationToken = default)
    {
        // Group rule sets by target type
        var groupedByType = context.Manifest.RuleSets
            .GroupBy(rs => rs.TargetType)
            .ToList();

        foreach (var group in groupedByType)
        {
            cancellationToken.ThrowIfCancellationRequested();

            var targetType = group.Key;
            var ruleSets = group.ToList();

            // Extract just the class name without namespace for file naming
            // Handle nested types (e.g., "Namespace.OuterClass+InnerClass" -> "InnerClass")
            var className = ExtractClassName(targetType);

            // Generate a validator for each rule set
            foreach (var ruleSet in ruleSets)
            {
                var code = GenerateValidator(context, targetType, ruleSet);
                var fileName = GeneratorUtilities.GenerateFileName($"{className}{ruleSet.Name}Validator", "");
                yield return CreateGeneratedFile(fileName, code);
            }
        }
    }

    private string GenerateValidator(GeneratorContext context, string targetType, RuleSetManifest ruleSet)
    {
        var builder = CreateCodeBuilder(context.Manifest.Version.ToString());

        // Extract just the class name without namespace
        // Handle nested types (e.g., "Namespace.OuterClass+InnerClass" -> "InnerClass")
        var className = ExtractClassName(targetType);
        var validatorName = $"{className}{ruleSet.Name}Validator";

        builder.AutoGeneratedHeader(
                Name,
                context.Manifest.Version.ToString(),
                context.Manifest.CreatedAt)
            .Usings(
                "System",
                "FluentValidation",
                "JD.Domain.Abstractions")
            .AppendLine();

        // Determine namespace from context or use default
        var namespaceValue = GetNamespace(context, className);
        builder.BeginNamespace(namespaceValue);

        // Generate class documentation
        builder.AppendLine("/// <summary>")
            .AppendLine($"/// FluentValidation validator for {className} using the '{ruleSet.Name}' rule set.")
            .AppendLine("/// </summary>");

        builder.BeginClass(validatorName, "public", "sealed", $"AbstractValidator<{className}>");

        // Generate constructor
        builder.AppendLine($"public {validatorName}()")
            .AppendLine("{");
        builder.Indent();

        // Generate rules
        foreach (var rule in ruleSet.Rules)
        {
            GenerateRule(builder, rule, className);
        }

        // Handle includes
        if (ruleSet.Includes.Count > 0)
        {
            builder.AppendLine()
                .AppendLine($"// Includes: {string.Join(", ", ruleSet.Includes)}");
        }

        builder.Unindent();
        builder.AppendLine("}");

        builder.EndClass();
        builder.EndNamespace();

        return builder.ToString();
    }

    private void GenerateRule(CodeBuilder builder, RuleManifest rule, string targetType)
    {
        // Map rule to FluentValidation syntax
        var propertyName = ExtractPropertyName(rule);

        if (string.IsNullOrEmpty(propertyName) && !string.IsNullOrEmpty(rule.Expression))
        {
            // Complex rule that can't be easily mapped - add as comment
            builder.AppendLine($"// Rule '{rule.Id}': {rule.Message ?? "No message"}");
            return;
        }

        // Build the rule
        var ruleBuilder = string.IsNullOrEmpty(propertyName)
            ? "RuleFor(x => x)"
            : $"RuleFor(x => x.{propertyName})";

        // Add validation based on rule category and metadata
        var validations = new List<string>();

        if (rule.Category == "Invariant" || rule.Category == "Validator")
        {
            // Try to map common patterns
            // Note: Expression.ToString() converts source code to expression tree format, e.g.:
            // - "!string.IsNullOrWhiteSpace(x.Name)" becomes "Not(IsNullOrWhiteSpace(x.Name))"
            // - "x.Name.Length <= 200" becomes "(x.Name.Length <= 200)"
            if (rule.Expression != null)
            {
                if (rule.Expression.Contains("IsNullOrWhiteSpace") ||
                    rule.Expression.Contains("IsNullOrEmpty") ||
                    rule.Expression.Contains("!string.IsNullOrWhiteSpace") ||
                    rule.Expression.Contains("!string.IsNullOrEmpty"))
                {
                    validations.Add("NotEmpty()");
                }
                else if (rule.Expression.Contains(".Length <=") || rule.Expression.Contains("Length <="))
                {
                    var maxLength = ExtractNumber(rule.Expression);
                    if (maxLength > 0)
                    {
                        validations.Add($"MaximumLength({maxLength})");
                    }
                }
                else if (rule.Expression.Contains(" >= 0") || rule.Expression.Contains(">= 0"))
                {
                    validations.Add("GreaterThanOrEqualTo(0)");
                }
                else
                {
                    // Generic must condition - use Must with lambda
                    validations.Add($"Must(x => /* {rule.Expression} */ true)");
                }
            }
            else
            {
                // No expression available, use Must placeholder
                validations.Add($"Must(x => /* {rule.Id} */ true)");
            }
        }

        // Add message if provided
        if (!string.IsNullOrEmpty(rule.Message))
        {
            var escapedMessage = EscapeMessage(rule.Message!);
            validations.Add($"WithMessage(\"{escapedMessage}\")");
        }

        // Add severity mapping
        validations.Add($"WithSeverity(Severity.{MapSeverity(rule.Severity)})");

        // Build the complete rule statement
        builder.AppendLine($"{ruleBuilder}");
        builder.Indent();
        foreach (var validation in validations)
        {
            builder.AppendLine($".{validation}");
        }
        builder.Unindent();
        builder.AppendLine(";")
            .AppendLine();
    }

    private string ExtractPropertyName(RuleManifest rule)
    {
        // Try to extract property name from expression
        if (string.IsNullOrEmpty(rule.Expression))
        {
            return string.Empty;
        }

        // Look for patterns like "x.PropertyName" using regex
        // This handles expressions like "x => Not(IsNullOrWhiteSpace(x.Name))"
        var match = System.Text.RegularExpressions.Regex.Match(
            rule.Expression,
            @"\b([a-z])\.([A-Z][a-zA-Z0-9]*)\b");

        if (match.Success)
        {
            return match.Groups[2].Value;
        }

        return string.Empty;
    }

    private int ExtractNumber(string expression)
    {
        // Split by common expression delimiters including parentheses
        var parts = expression.Split([' ', '=', '<', '>', '(', ')'], StringSplitOptions.RemoveEmptyEntries);
        foreach (var part in parts)
        {
            if (int.TryParse(part, out var number))
            {
                return number;
            }
        }
        return 0;
    }

    private string MapSeverity(RuleSeverity severity)
    {
        return severity switch
        {
            RuleSeverity.Info => "Info",
            RuleSeverity.Warning => "Warning",
            RuleSeverity.Error => "Error",
            RuleSeverity.Critical => "Error", // FluentValidation doesn't have Critical, map to Error
            _ => "Error"
        };
    }

    private string GetNamespace(GeneratorContext context, string targetType)
    {
        // Try to get namespace from context properties
        if (context.Properties.TryGetValue("Namespace", out var namespaceStr))
        {
            return $"{namespaceStr}.Validators";
        }

        // Default namespace
        return $"{context.Manifest.Name}.Validators";
    }

    /// <summary>
    /// Extracts just the class name from a fully qualified type name.
    /// Handles nested types (e.g., "Namespace.OuterClass+InnerClass" -> "InnerClass").
    /// </summary>
    private static string ExtractClassName(string targetType)
    {
        // First handle nested types (+ separator)
        var plusIndex = targetType.LastIndexOf('+');
        if (plusIndex >= 0)
        {
            return targetType.Substring(plusIndex + 1);
        }

        // Then handle namespace separator
        var dotIndex = targetType.LastIndexOf('.');
        if (dotIndex >= 0)
        {
            return targetType.Substring(dotIndex + 1);
        }

        return targetType;
    }

    /// <summary>
    /// Escapes special characters in a message for use in a C# string literal.
    /// Does not add surrounding quotes.
    /// </summary>
    private static string EscapeMessage(string message)
    {
        return message
            .Replace("\\", "\\\\")
            .Replace("\"", "\\\"")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t");
    }
}
