using System;
using System.Collections.Generic;
using System.Linq;
using System.Text.RegularExpressions;
using JD.Domain.Abstractions;
using JD.Domain.DomainModel.Generator.Options;
using JD.Domain.Generators.Core;

namespace JD.Domain.DomainModel.Generator.Generators;

/// <summary>
/// Generates domain proxy wrapper types that wrap EF entities
/// and enforce rules in property accessors.
/// </summary>
public sealed class DomainProxyGenerator
{
    /// <summary>
    /// Generates a domain proxy type for the given entity.
    /// </summary>
    public GeneratedFile Generate(
        GeneratorContext context,
        EntityManifest entity,
        IReadOnlyList<RuleSetManifest> ruleSets,
        DomainModelOptions options)
    {
        var builder = new CodeBuilder();
        var entityClassName = ExtractClassName(entity.TypeName);
        var domainTypeName = $"{options.DomainTypePrefix}{entityClassName}";

        // Build list of properties that have rules
        var propertiesWithRules = GetPropertiesWithRules(entity, ruleSets);

        // Generate the file
        GenerateHeader(builder, context, options);
        GenerateUsings(builder, options);

        var namespaceValue = GetNamespace(context, entity, options);
        builder.BeginNamespace(namespaceValue);

        GenerateClassDocumentation(builder, entity, entityClassName);
        GenerateClass(builder, context, entity, entityClassName, domainTypeName, ruleSets, propertiesWithRules, options);

        // Generate partial class for user extensions
        if (options.GeneratePartialClasses)
        {
            builder.AppendLine();
            GeneratePartialClassStub(builder, domainTypeName, entityClassName);
        }

        builder.EndNamespace();

        var fileName = GeneratorUtilities.GenerateFileName(domainTypeName, "");
        return new GeneratedFile
        {
            FileName = fileName,
            Content = builder.ToString()
        };
    }

    private void GenerateHeader(CodeBuilder builder, GeneratorContext context, DomainModelOptions options)
    {
        builder.AppendLine("// <auto-generated>")
            .AppendLine("// Generated by DomainModelGenerator")
            .AppendLine($"// Version: {context.Manifest.Version}")
            .AppendLine($"// Generated at: {DateTimeOffset.UtcNow:O}")
            .AppendLine("// </auto-generated>")
            .AppendLine()
            .AppendLine("#nullable enable")
            .AppendLine();
    }

    private void GenerateUsings(CodeBuilder builder, DomainModelOptions options)
    {
        var usings = new List<string>
        {
            "System",
            "System.Collections.Generic",
            "JD.Domain.Abstractions"
        };

        usings.AddRange(options.AdditionalUsings);
        usings.Sort();

        foreach (var ns in usings.Distinct())
        {
            builder.AppendLine($"using {ns};");
        }

        builder.AppendLine();
    }

    private void GenerateClassDocumentation(CodeBuilder builder, EntityManifest entity, string entityClassName)
    {
        builder.AppendLine("/// <summary>")
            .AppendLine($"/// Domain proxy for {entityClassName} with rule enforcement in property accessors.")
            .AppendLine("/// </summary>")
            .AppendLine("/// <remarks>")
            .AppendLine("/// This type wraps the underlying EF entity and provides:")
            .AppendLine("/// - Property-level validation on setters")
            .AppendLine("/// - Factory method with full validation")
            .AppendLine("/// - Implicit conversion to EF entity for EF interop")
            .AppendLine("/// </remarks>");
    }

    private void GenerateClass(
        CodeBuilder builder,
        GeneratorContext context,
        EntityManifest entity,
        string entityClassName,
        string domainTypeName,
        IReadOnlyList<RuleSetManifest> ruleSets,
        HashSet<string> propertiesWithRules,
        DomainModelOptions options)
    {
        builder.BeginClass(domainTypeName, "public", "sealed partial");

        // Generate fields
        GenerateFields(builder, entityClassName, options);

        // Generate constructor
        GenerateConstructor(builder, entityClassName, domainTypeName, options);

        // Generate Entity property and implicit conversion
        GenerateEntityAccess(builder, entityClassName, domainTypeName, options);

        // Generate properties
        builder.AppendLine()
            .AppendLine("#region Properties");
        builder.AppendLine();

        foreach (var property in entity.Properties)
        {
            var hasRules = propertiesWithRules.Contains(property.Name);
            var isKey = entity.KeyProperties.Contains(property.Name);
            GenerateProperty(builder, property, entityClassName, hasRules, isKey, options);
        }

        builder.AppendLine()
            .AppendLine("#endregion");

        // Generate factory methods
        builder.AppendLine()
            .AppendLine("#region Factory Methods");
        builder.AppendLine();

        GenerateCreateMethod(builder, entity, entityClassName, domainTypeName, ruleSets, options);
        GenerateFromEntityMethod(builder, entityClassName, domainTypeName, options);

        builder.AppendLine()
            .AppendLine("#endregion");

        // Generate mutation methods
        if (options.GenerateWithMethods)
        {
            builder.AppendLine()
                .AppendLine("#region Mutation Methods");
            builder.AppendLine();

            foreach (var property in entity.Properties)
            {
                // Skip key properties and computed properties
                var isKey = entity.KeyProperties.Contains(property.Name);
                if (isKey || property.IsComputed)
                {
                    continue;
                }

                var hasRules = propertiesWithRules.Contains(property.Name);
                GenerateWithMethod(builder, property, domainTypeName, hasRules, options);
            }

            builder.AppendLine()
                .AppendLine("#endregion");
        }

        // Generate validation methods
        builder.AppendLine()
            .AppendLine("#region Validation");
        builder.AppendLine();

        GenerateValidatePropertyMethod(builder, entityClassName);
        GenerateValidateMethod(builder, entityClassName, options);

        builder.AppendLine()
            .AppendLine("#endregion");

        builder.EndClass();
    }

    private void GenerateFields(CodeBuilder builder, string entityClassName, DomainModelOptions options)
    {
        builder.AppendLine($"private readonly {entityClassName} _entity;")
            .AppendLine("private readonly IDomainEngine? _engine;");

        if (options.IncludeDomainContext)
        {
            builder.AppendLine("private readonly DomainContext? _context;");
        }

        builder.AppendLine();
    }

    private void GenerateConstructor(CodeBuilder builder, string entityClassName, string domainTypeName, DomainModelOptions options)
    {
        builder.AppendLine("/// <summary>")
            .AppendLine($"/// Initializes a new instance of the <see cref=\"{domainTypeName}\"/> class.")
            .AppendLine("/// </summary>");

        if (options.IncludeDomainContext)
        {
            builder.AppendLine($"private {domainTypeName}({entityClassName} entity, IDomainEngine? engine = null, DomainContext? context = null)")
                .AppendLine("{")
                .Indent()
                .AppendLine($"_entity = entity ?? throw new ArgumentNullException(nameof(entity));")
                .AppendLine("_engine = engine;")
                .AppendLine("_context = context;")
                .Unindent()
                .AppendLine("}")
                .AppendLine();
        }
        else
        {
            builder.AppendLine($"private {domainTypeName}({entityClassName} entity, IDomainEngine? engine = null)")
                .AppendLine("{")
                .Indent()
                .AppendLine($"_entity = entity ?? throw new ArgumentNullException(nameof(entity));")
                .AppendLine("_engine = engine;")
                .Unindent()
                .AppendLine("}")
                .AppendLine();
        }
    }

    private void GenerateEntityAccess(CodeBuilder builder, string entityClassName, string domainTypeName, DomainModelOptions options)
    {
        builder.AppendLine("/// <summary>")
            .AppendLine("/// Gets the underlying EF entity for persistence operations.")
            .AppendLine("/// </summary>")
            .AppendLine($"public {entityClassName} Entity => _entity;")
            .AppendLine();

        if (options.GenerateImplicitConversion)
        {
            builder.AppendLine("/// <summary>")
                .AppendLine($"/// Implicitly converts a <see cref=\"{domainTypeName}\"/> to its underlying EF entity.")
                .AppendLine("/// </summary>")
                .AppendLine($"public static implicit operator {entityClassName}({domainTypeName} domain) => domain._entity;");
        }
    }

    private void GenerateProperty(
        CodeBuilder builder,
        PropertyManifest property,
        string entityClassName,
        bool hasRules,
        bool isKey,
        DomainModelOptions options)
    {
        var typeName = FormatTypeName(property);

        // Key properties are read-only
        if (isKey)
        {
            builder.AppendLine($"public {typeName} {property.Name} => _entity.{property.Name};")
                .AppendLine();
            return;
        }

        // Computed properties are read-only
        if (property.IsComputed)
        {
            builder.AppendLine($"public {typeName} {property.Name} => _entity.{property.Name};")
                .AppendLine();
            return;
        }

        // Properties with rules get validation in setter
        if (hasRules && options.ValidationMode == PropertyValidationMode.OnSet)
        {
            builder.AppendLine($"public {typeName} {property.Name}")
                .AppendLine("{")
                .Indent()
                .AppendLine($"get => _entity.{property.Name};")
                .AppendLine("set")
                .AppendLine("{")
                .Indent()
                .AppendLine($"var result = ValidateProperty(nameof({property.Name}), value);")
                .AppendLine("if (!result.IsValid)")
                .AppendLine("{")
                .Indent()
                .AppendLine("throw new DomainValidationException(result.Errors);")
                .Unindent()
                .AppendLine("}")
                .AppendLine($"_entity.{property.Name} = value;")
                .Unindent()
                .AppendLine("}")
                .Unindent()
                .AppendLine("}")
                .AppendLine();
        }
        else
        {
            // Simple pass-through property
            builder.AppendLine($"public {typeName} {property.Name}")
                .AppendLine("{")
                .Indent()
                .AppendLine($"get => _entity.{property.Name};")
                .AppendLine($"set => _entity.{property.Name} = value;")
                .Unindent()
                .AppendLine("}")
                .AppendLine();
        }
    }

    private void GenerateCreateMethod(
        CodeBuilder builder,
        EntityManifest entity,
        string entityClassName,
        string domainTypeName,
        IReadOnlyList<RuleSetManifest> ruleSets,
        DomainModelOptions options)
    {
        builder.AppendLine("/// <summary>")
            .AppendLine($"/// Creates a new {domainTypeName} with validation.")
            .AppendLine("/// </summary>");

        // Build parameter list
        var parameters = new List<string>();
        foreach (var property in entity.Properties)
        {
            if (property.IsComputed)
            {
                continue;
            }

            var typeName = FormatTypeName(property);
            var paramName = ToCamelCase(property.Name);

            // Make optional parameters have default values
            if (!property.IsRequired && !entity.KeyProperties.Contains(property.Name))
            {
                parameters.Add($"{typeName} {paramName} = default");
            }
            else
            {
                parameters.Add($"{typeName} {paramName}");
            }
        }

        // Add engine and context parameters
        parameters.Add("IDomainEngine? engine = null");
        if (options.IncludeDomainContext)
        {
            parameters.Add("DomainContext? context = null");
        }

        var parameterString = string.Join(",\n            ", parameters);
        builder.AppendLine($"public static Result<{domainTypeName}> Create(")
            .Indent()
            .AppendLine($"{parameterString})")
            .Unindent()
            .AppendLine("{")
            .Indent();

        // Create the entity
        builder.AppendLine($"var entity = new {entityClassName}");
        builder.AppendLine("{");
        builder.Indent();

        foreach (var property in entity.Properties)
        {
            if (property.IsComputed)
            {
                continue;
            }
            var paramName = ToCamelCase(property.Name);
            builder.AppendLine($"{property.Name} = {paramName},");
        }

        builder.Unindent();
        builder.AppendLine("};");
        builder.AppendLine();

        // Create the domain wrapper
        if (options.IncludeDomainContext)
        {
            builder.AppendLine($"var domain = new {domainTypeName}(entity, engine, context);");
        }
        else
        {
            builder.AppendLine($"var domain = new {domainTypeName}(entity, engine);");
        }

        builder.AppendLine();

        // Validate using the Create rule set
        builder.AppendLine($"// Validate using \"{options.CreateRuleSet}\" rule set")
            .AppendLine($"var result = domain.Validate(\"{options.CreateRuleSet}\");")
            .AppendLine("if (!result.IsValid)")
            .AppendLine("{")
            .Indent()
            .AppendLine($"return Result<{domainTypeName}>.Failure(result.Errors);")
            .Unindent()
            .AppendLine("}")
            .AppendLine()
            .AppendLine($"return Result<{domainTypeName}>.Success(domain);")
            .Unindent()
            .AppendLine("}")
            .AppendLine();
    }

    private void GenerateFromEntityMethod(
        CodeBuilder builder,
        string entityClassName,
        string domainTypeName,
        DomainModelOptions options)
    {
        builder.AppendLine("/// <summary>")
            .AppendLine("/// Wraps an existing EF entity as a domain model.")
            .AppendLine("/// </summary>")
            .AppendLine("/// <remarks>")
            .AppendLine("/// This method does not validate the entity. Use for wrapping")
            .AppendLine("/// entities loaded from the database where data is assumed valid.")
            .AppendLine("/// </remarks>");

        if (options.IncludeDomainContext)
        {
            builder.AppendLine($"public static {domainTypeName} FromEntity({entityClassName} entity, IDomainEngine? engine = null, DomainContext? context = null)")
                .AppendLine("{")
                .Indent()
                .AppendLine($"return new {domainTypeName}(entity, engine, context);")
                .Unindent()
                .AppendLine("}");
        }
        else
        {
            builder.AppendLine($"public static {domainTypeName} FromEntity({entityClassName} entity, IDomainEngine? engine = null)")
                .AppendLine("{")
                .Indent()
                .AppendLine($"return new {domainTypeName}(entity, engine);")
                .Unindent()
                .AppendLine("}");
        }
    }

    private void GenerateWithMethod(
        CodeBuilder builder,
        PropertyManifest property,
        string domainTypeName,
        bool hasRules,
        DomainModelOptions options)
    {
        var typeName = FormatTypeName(property);
        var paramName = ToCamelCase(property.Name);

        builder.AppendLine("/// <summary>")
            .AppendLine($"/// Updates the {property.Name} property with validation.")
            .AppendLine("/// </summary>");

        if (options.IncludeDomainContext)
        {
            builder.AppendLine($"public Result<{domainTypeName}> With{property.Name}({typeName} {paramName}, DomainContext? context = null)")
                .AppendLine("{");
        }
        else
        {
            builder.AppendLine($"public Result<{domainTypeName}> With{property.Name}({typeName} {paramName})")
                .AppendLine("{");
        }

        builder.Indent();

        if (hasRules)
        {
            builder.AppendLine($"var result = ValidateProperty(nameof({property.Name}), {paramName});")
                .AppendLine("if (!result.IsValid)")
                .AppendLine("{")
                .Indent()
                .AppendLine($"return Result<{domainTypeName}>.Failure(result.Errors);")
                .Unindent()
                .AppendLine("}");
        }

        builder.AppendLine($"_entity.{property.Name} = {paramName};")
            .AppendLine($"return Result<{domainTypeName}>.Success(this);")
            .Unindent()
            .AppendLine("}")
            .AppendLine();
    }

    private void GenerateValidatePropertyMethod(CodeBuilder builder, string entityClassName)
    {
        builder.AppendLine("/// <summary>")
            .AppendLine("/// Validates a single property value using the domain engine.")
            .AppendLine("/// </summary>")
            .AppendLine("private RuleEvaluationResult ValidateProperty(string propertyName, object? value)")
            .AppendLine("{")
            .Indent()
            .AppendLine("if (_engine == null)")
            .AppendLine("{")
            .Indent()
            .AppendLine("return RuleEvaluationResult.Success();")
            .Unindent()
            .AppendLine("}")
            .AppendLine()
            .AppendLine("// Evaluate property-specific rules")
            .AppendLine("var options = new RuleEvaluationOptions")
            .AppendLine("{")
            .Indent()
            .AppendLine("PropertyName = propertyName")
            .Unindent()
            .AppendLine("};")
            .AppendLine()
            .AppendLine("return _engine.Evaluate(_entity, options);")
            .Unindent()
            .AppendLine("}")
            .AppendLine();
    }

    private void GenerateValidateMethod(CodeBuilder builder, string entityClassName, DomainModelOptions options)
    {
        builder.AppendLine("/// <summary>")
            .AppendLine("/// Validates the entire entity using the specified rule set.")
            .AppendLine("/// </summary>")
            .AppendLine("public RuleEvaluationResult Validate(string? ruleSet = null)")
            .AppendLine("{")
            .Indent()
            .AppendLine("if (_engine == null)")
            .AppendLine("{")
            .Indent()
            .AppendLine("return RuleEvaluationResult.Success();")
            .Unindent()
            .AppendLine("}")
            .AppendLine()
            .AppendLine("var options = ruleSet != null")
            .Indent()
            .AppendLine("? new RuleEvaluationOptions { RuleSet = ruleSet }")
            .AppendLine(": null;")
            .Unindent()
            .AppendLine()
            .AppendLine("return _engine.Evaluate(_entity, options);")
            .Unindent()
            .AppendLine("}");
    }

    private void GeneratePartialClassStub(CodeBuilder builder, string domainTypeName, string entityClassName)
    {
        builder.AppendLine("/// <summary>")
            .AppendLine($"/// Partial class for user-defined extensions to {domainTypeName}.")
            .AppendLine("/// </summary>")
            .AppendLine("/// <remarks>")
            .AppendLine("/// Add semantic methods here, for example:")
            .AppendLine($"/// <code>public Result&lt;{domainTypeName}&gt; Rename(string newName) =&gt; WithName(newName);</code>")
            .AppendLine("/// </remarks>")
            .BeginClass(domainTypeName, "public", "sealed partial")
            .AppendLine("// Add custom methods here")
            .EndClass();
    }

    private HashSet<string> GetPropertiesWithRules(EntityManifest entity, IReadOnlyList<RuleSetManifest> ruleSets)
    {
        var properties = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        foreach (var ruleSet in ruleSets)
        {
            foreach (var rule in ruleSet.Rules)
            {
                var propertyName = ExtractPropertyNameFromExpression(rule.Expression);
                if (!string.IsNullOrEmpty(propertyName))
                {
                    properties.Add(propertyName);
                }
            }
        }

        return properties;
    }

    private string ExtractPropertyNameFromExpression(string? expression)
    {
        if (string.IsNullOrEmpty(expression))
        {
            return string.Empty;
        }

        // Look for patterns like "x.PropertyName" using regex
        var match = Regex.Match(expression, @"\b[a-z]\.([A-Z][a-zA-Z0-9]*)\b");
        if (match.Success)
        {
            return match.Groups[1].Value;
        }

        return string.Empty;
    }

    private string GetNamespace(GeneratorContext context, EntityManifest entity, DomainModelOptions options)
    {
        if (!string.IsNullOrEmpty(options.Namespace))
        {
            return options.Namespace!;
        }

        if (!string.IsNullOrEmpty(entity.Namespace))
        {
            return $"{entity.Namespace}.Domain";
        }

        return $"{context.Manifest.Name}.Domain";
    }

    private static string ExtractClassName(string typeName)
    {
        var plusIndex = typeName.LastIndexOf('+');
        if (plusIndex >= 0)
        {
            return typeName.Substring(plusIndex + 1);
        }

        var dotIndex = typeName.LastIndexOf('.');
        if (dotIndex >= 0)
        {
            return typeName.Substring(dotIndex + 1);
        }

        return typeName;
    }

    private static string FormatTypeName(PropertyManifest property)
    {
        var typeName = property.TypeName;

        // Handle common type name mappings
        typeName = typeName switch
        {
            "System.String" => "string",
            "System.Int32" => "int",
            "System.Int64" => "long",
            "System.Boolean" => "bool",
            "System.Decimal" => "decimal",
            "System.Double" => "double",
            "System.Single" => "float",
            "System.Guid" => "Guid",
            "System.DateTime" => "DateTime",
            "System.DateTimeOffset" => "DateTimeOffset",
            "System.Byte" => "byte",
            "System.Int16" => "short",
            _ => typeName
        };

        // Remove namespace prefix if present
        var dotIndex = typeName.LastIndexOf('.');
        if (dotIndex >= 0)
        {
            typeName = typeName.Substring(dotIndex + 1);
        }

        // Add nullability for reference types that are not required
        // Note: Value types from reflection are handled separately - they're nullable only if Nullable<T>
        if (!property.IsRequired && !typeName.EndsWith("?") && !IsValueType(typeName))
        {
            // Only add ? to reference types that aren't string (string is special in C#)
            if (typeName != "string")
            {
                typeName += "?";
            }
        }

        return typeName;
    }

    private static bool IsValueType(string typeName)
    {
        return typeName switch
        {
            "int" or "long" or "short" or "byte" or
            "bool" or "decimal" or "double" or "float" or
            "Guid" or "DateTime" or "DateTimeOffset" => true,
            _ when typeName.StartsWith("Nullable<") => true,
            _ => false
        };
    }

    private static string ToCamelCase(string name)
    {
        if (string.IsNullOrEmpty(name))
        {
            return name;
        }

        return char.ToLowerInvariant(name[0]) + name.Substring(1);
    }
}
